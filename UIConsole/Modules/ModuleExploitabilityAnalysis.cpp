/*
Copyright (C) 2013 George Nicolaou <george[at]preaver.[dot]com>

This file is part of Exploitation Toolkit Icarus (ETI) UI Console.

Exploitation Toolkit Icarus (ETI) UI Console is free software: you can redistribute
it and/or modify it under the terms of the GNU General Public License as
published by the Free Software Foundation, either version 3 of the License,
or (at your option) any later version.

Exploitation Toolkit Icarus (ETI) UI Console is distributed in the hope that it
will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Exploitation Toolkit Icarus (ETI) UI Console.
If not, see <http://www.gnu.org/licenses/>.
*/


#include "ModuleExploitabilityAnalysis.h"
#include <ExecutionMonitor.h>
#include <ExceptionSignal.h>
#include <IVulnerability.h>
#include <ExploitabilityAnalysis.h>
#include <Payload.h>
#include <Address.h>
void ExecuteExploitabilityAnalysis( PMODULEARGS lpModuleArgs );
BOOL MyMonitorCallback( ExecutionMonitor::MONITOR_EVENT_INFO * lpInfo );
BOOL TerminationCallback();
char * GetPayloadTypeString( PAYLOAD_ELEMENT_TYPE eType );

void * lpExplAnalysisArgs[2];

MODULEARGS arsModuleExploitabilityAnalysisArgs[] = {
	{
		"p",
		"The process ID of the process to attach to",
		TYPE_INT,
		FALSE,
		FALSE,
		&lpExplAnalysisArgs[0]
	},
	{
		"i",
		"Image file to execute instead of attaching",
		TYPE_STRING,
		FALSE,
		FALSE
	},
	{
		"r",
		"Automatically restart the program after an unhandled exception or termination",
		TYPE_FLAG,
		FALSE,
		FALSE
	}
};

MODULE sModuleExploitabilityAnalysis = {
	"Exploitability Analysis",
	"Run exploitability analysis on a program",
	"exploitability_analysis",
	"ea",
	MYARRAYSIZE( arsModuleExploitabilityAnalysisArgs ),
	(PMODULEARGS)&arsModuleExploitabilityAnalysisArgs,
	&ExecuteExploitabilityAnalysis
};

ExploitabilityAnalysis objExploitabilityAnalysis;

ExecutionMonitor objExecutionMonitor;

void ExecuteExploitabilityAnalysis( PMODULEARGS lpModuleArgs )
{
	BOOL bDoAttach = lpModuleArgs->bSet;
	BOOL bDoExecute = (lpModuleArgs+1)->bSet;	
	if( bDoAttach && bDoExecute ) {
		printf( "Error: You cannot specify both attach and execute flags" );
		return;
	}
	
	objExecutionMonitor.set_monitor_callback( 
		(ExecutionMonitor::MONITOR_CALLBACK)&MyMonitorCallback );

	//XXX Add flags to enable/disable vulnerability types
	objExploitabilityAnalysis.enable_vulnerability_modules( VULNERABILITY_ALL );

	//Blocking code begins below
	if( bDoAttach ) {
		if( objExecutionMonitor.attach_and_monitor( 
			(int)lpModuleArgs->lpArgument, ExecutionMonitor::MONITOR_EXCEPTIONS ) 
			== FALSE ) {
				return;
		}
	}
	else if( bDoExecute ) {
		if( objExecutionMonitor.create_and_monitor( 
			(char *)(lpModuleArgs+1)->lpArgument, NULL, 
			ExecutionMonitor::MONITOR_EXCEPTIONS ) == FALSE ) {
				return;
		}
	}
	else {
		printf( "Error: No arguments given" );
		return;
	}
}

BOOL MyMonitorCallback( ExecutionMonitor::MONITOR_EVENT_INFO * lpInfo )
{
	char cInput = 0;
	if( lpInfo->eType != ExecutionMonitor::EVENT_EXCEPTION ) return TRUE;

	printf( "%s at [%#X]:\n\tThread: %d\nWould you like to analyze? (Y/N):", 
		lpInfo->uType.lpException->get_exception_name(), lpInfo->ulEventAddress, 
		lpInfo->nThreadId );

	scanf( " %c", &cInput );

	if( cInput == 'N' || cInput == 'n' ) {
		return FALSE;
	}

	if( cInput == 'Y' || cInput == 'y' ) {
		vector<IVulnerability *> vFoundVulns;
		if( objExploitabilityAnalysis.run_vulnerability_classification( 
			objExecutionMonitor.get_debugger(), &vFoundVulns ) ) {
				printf("Vulnerability Classified as:\n");
				for( int i = 0; i < vFoundVulns.size(); i++ ) {
					printf("[%d]\t%s: %d%%\n", i, 
						vFoundVulns[i]->get_vulnerability_name(), 
						vFoundVulns[i]->get_vulnerability_score() );
				}
				BOOL bOk = FALSE;
				if( vFoundVulns.size() > 1 ) {
					while( bOk == FALSE ) {
						printf( "\nWhich vulnerability should we analyze? [0-%d]:", 
							vFoundVulns.size() - 1 );
						scanf( " %c\n", &cInput );
						if( (int)cInput >= vFoundVulns.size() ) {
							printf( "Bad number given" );
						}
						else {
							bOk = TRUE;
						}
					}
				}
				else {
					cInput = 0;
				}

				IVulnerability * lpVulnerability = vFoundVulns[(int)cInput];
				
				if( objExploitabilityAnalysis.run_exploitability_analysis( 
					objExecutionMonitor.get_debugger(), lpVulnerability ) 
					== FALSE ) {
						printf("Vulnerability analysis produced no results");
						return TRUE;
				}

				if( objExploitabilityAnalysis.run_skeleton_implementation( 
					objExecutionMonitor.get_debugger(), lpVulnerability ) 
					== FALSE ) {
						printf("Implementation analysis produced no results");
						return TRUE;
				}

				bOk = FALSE;
				while( bOk == FALSE ) {
					printf( "Would you like to print the payload structure?  (Y/N):" );
					scanf( " %c", &cInput );
					if( cInput == 'Y' || cInput == 'y' || cInput == 'n' || 
						cInput == 'N' ) {
							bOk = TRUE;
					} 
				}

				if( cInput == 'Y' || cInput == 'y' ) {
					Payload * lpPayload = lpVulnerability->get_payload();
					PAYLOAD_ELEMENT * lpPayloadElement = (PAYLOAD_ELEMENT *)
						lpPayload->get_head_element();
					printf( "Payload:\n");
					while( lpPayloadElement != NULL ) {
						if( lpPayloadElement->eType == PAYLOAD_ADDRESS_MULTIPLE ) {
							printf( "\t[%s] Size: %#X (%d)\n", GetPayloadTypeString( 
								lpPayloadElement->eType ), 
								lpPayloadElement->nSize, 
								lpPayloadElement->nSize );
							for( int i = 0; i < 
								(int)lpPayloadElement->u.vPayloadAddresses->size(); 
								i++ ) {
									printf( "\t\tRetn Addr: %#X\n", 
										lpPayloadElement->u.vPayloadAddresses->at(i)->get_address() );
							}
						}
						else {
							printf("\t[%s] * %#X(%d)\n", GetPayloadTypeString( 
								lpPayloadElement->eType ), lpPayloadElement->nSize, 
								lpPayloadElement->nSize );
						}
						lpPayloadElement = lpPayloadElement->lpsNext;
					}
				}
		}
	}
	return TRUE;
}

BOOL TerminationCallback()
{
	printf("Would you like to execute the program again?");
	return TRUE;
}

char * GetPayloadTypeString( PAYLOAD_ELEMENT_TYPE eType )
{
	switch( eType ) {
	case PAYLOAD_CODE: return "CODE";
	case PAYLOAD_ADDRESS: return "ADDRESS";
	case PAYLOAD_ADDRESS_MULTIPLE: return "ADDRESSES";
	case PAYLOAD_BAD: return "BAD CHARS";
	default: return "Unknown";
	}
}